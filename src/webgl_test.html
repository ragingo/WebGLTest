<!DOCTYPE html>
<html>
<head>
<title>Shader Practice</title>

<script type="text/javascript" src="ragii.js"></script>

<script type="text/javascript">

	// View
	var view = {

		// スライダ群
		sliders: null,

		// エフェクト選択ドロップダウン
		effectSelector: null,

		// 描画対象のキャンバス
		canvas: null,

		// 初期化
		init: function() {
			// スライダ初期化
			this.sliders = {
				r: { body: ragii.dom.getElem("#slider_color_r"), label: ragii.dom.getElem("#label_color_r_value") },
				g: { body: ragii.dom.getElem("#slider_color_g"), label: ragii.dom.getElem("#label_color_g_value") },
				b: { body: ragii.dom.getElem("#slider_color_b"), label: ragii.dom.getElem("#label_color_b_value") },
				a: { body: ragii.dom.getElem("#slider_color_a"), label: ragii.dom.getElem("#label_color_a_value") },
				vivid_k1: { body: ragii.dom.getElem("#slider_vivid_k1"), label: ragii.dom.getElem("#label_vivid_k1_value") },
				vivid_k2: { body: ragii.dom.getElem("#slider_vivid_k2"), label: ragii.dom.getElem("#label_vivid_k2_value") },
			};
			{
				var that = this;
				this.sliders.r.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.r); };
				this.sliders.g.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.g); };
				this.sliders.b.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.b); };
				this.sliders.a.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.a); };
				this.sliders.vivid_k1.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.vivid_k1); };
				this.sliders.vivid_k2.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.vivid_k2); };
			}

			this.effectSelector = ragii.dom.getElem('#comboEffectSelector');
			this.effectSelector.onchange = this.onEffectTypeSelectedValueChanged;

			this.canvas = ragii.dom.getElem('#canvas');
		},

		// 色指定スライダーの値変更時
		onColorSliderValueChanged: function(slider) {
			slider.label.innerText = slider.body.value;
		},

		// エフェクト種別切替時
		onEffectTypeSelectedValueChanged: function() {
			if (view.getSelectedEffectType() == 16) {
				Array.prototype.forEach.call(
					ragii.dom.getElems(".vivid_params"),
					function(elem) {
						elem.style.visibility = "visible";
					}
				);
			}
			else {
				Array.prototype.forEach.call(
					ragii.dom.getElems(".vivid_params"),
					function(elem) {
						elem.style.visibility = "collapse";
					}
				);
			}
		},

		getSelectedEffectType: function() {
			var value = this.effectSelector.options[this.effectSelector.selectedIndex].value;
			return parseInt(value, 10);
		},

		getEditColor: function() {
			return [
				this.sliders.r.body.value,
				this.sliders.g.body.value,
				this.sliders.b.body.value,
				this.sliders.a.body.value
			];
		},

		getVividEffectParameters: function() {
			return [
				this.sliders.vivid_k1.body.value,
				this.sliders.vivid_k2.body.value
			];
		},
	};

	// グラフィックスクラス
	var Graphics = function() {
		this.gl = null;
		this.program = null;
		this.texture = null;
		this.texture_source = "res/Lenna.png";
	};

	// 初期化
	Graphics.prototype.init = function() {

		this.gl = view.canvas.getContext('webgl');
		if (!this.gl) {
			return false;
		}

		var gl = this.gl;
		var that = this;

		ragii.http.get("/default_vs.glsl", function(xhr) {
			var vs_src = xhr.responseText;

			ragii.http.get("/default_fs.glsl", function(xhr2) {
				var fs_src = xhr2.responseText;

				that.program = gl.createProgram();

				// vs 生成 & コンパイル
				var vs = gl.createShader(gl.VERTEX_SHADER);
				that.compileShader(vs, vs_src);
				gl.attachShader(that.program, vs);

				// fs 生成 & コンパイル
				var fs = gl.createShader(gl.FRAGMENT_SHADER);
				that.compileShader(fs, fs_src);
				gl.attachShader(that.program, fs);

				gl.linkProgram(that.program);

				if (!gl.getProgramParameter(that.program, gl.LINK_STATUS)) {
					console.log(gl.getProgramInfoLog(that.program));
					return false;
				}

				gl.useProgram(that.program);

				// 深度テストの有効化
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);

				gl.activeTexture(gl.TEXTURE0);

				that.createTexture(that.texture_source);
			});

		});

		return true;
	}

	Graphics.prototype.render = function() {

		if (!this.program) {
			return;
		}

		var gl = this.gl;
		// クリア
		gl.clearColor(0.0, 0.0, 0.0, 1.0);
		gl.clearDepth(1.0);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		gl.bindTexture(gl.TEXTURE_2D, this.texture);

		var uniformLocation = {
			texture: gl.getUniformLocation(this.program, 'texture'),
			effectType: gl.getUniformLocation(this.program, 'effectType'),
			textureSize: gl.getUniformLocation(this.program, 'textureSize'),
			editColor: gl.getUniformLocation(this.program, 'editColor'),
			vividParams: gl.getUniformLocation(this.program, 'vividParams'),
		}
		
		// テクスチャ登録
		gl.uniform1i(uniformLocation.texture, 0);
		gl.uniform2fv(uniformLocation.textureSize, [canvas.width, canvas.height]);
		gl.uniform4fv(uniformLocation.editColor, view.getEditColor());
		gl.uniform2fv(uniformLocation.vividParams, view.getVividEffectParameters());

		// エフェクト切り替え
		gl.uniform1i(uniformLocation.effectType, view.getSelectedEffectType());

		const tex_w = 512.0;
		const tex_h = 512.0;
		var texCoords = [
			{ left:   0, top:   0, width: 256, height: 256 },
			{ left:   0, top: 256, width: 256, height: 256 },
			{ left: 256, top:   0, width: 256, height: 256 },
			{ left: 256, top: 256, width: 256, height: 256 },
		];

		// 頂点バッファ更新
		var vertices = [];
		for (var i = 0; i < texCoords.length; i++) {
			var tc = texCoords[i];
			var tmp_pos = {
				left:   (tc.left / tex_w) * 2.0 - 1.0,
				top:    (tc.top / tex_h) * 2.0 - 1.0,
				width:  (tc.width / tex_w) * 2.0 - 1.0,
				height: (tc.height / tex_h) * 2.0 - 1.0,
				right:  ((tc.left + tc.width) / tex_w) * 2.0 - 1.0,
				bottom: ((tc.top + tc.height) / tex_h) * 2.0 - 1.0,
			};
			var tmp_texCoord = {
				left:   tc.left / tex_w,
				top:    tc.top / tex_h,
				width:  tc.width / tex_w,
				height: tc.height / tex_h,
				right:  (tc.left + tc.width) / tex_w,
				bottom: (tc.top + tc.height) / tex_h,
			};
			var pos = [
				tmp_pos.left, tmp_pos.bottom, 0,
				tmp_pos.right, tmp_pos.bottom, 0,
				tmp_pos.left, tmp_pos.top, 0,
				tmp_pos.right, tmp_pos.top, 0,
			];
			var texCoord = [
				tmp_texCoord.left, tmp_texCoord.bottom,
				tmp_texCoord.right, tmp_texCoord.bottom,
				tmp_texCoord.left, tmp_texCoord.top,
				tmp_texCoord.right, tmp_texCoord.top,
			];
			vertices.push({
				pos: pos,
				texCoord: texCoord,
			});
		}

		// // 左上
		// vertices.push({
		// 	pos: [
		// 		-1.0,  0.0,  0.0,
		// 		 0.0,  0.0,  0.0,
		// 		-1.0,  1.0,  0.0,
		// 		 0.0,  1.0,  0.0,
		// 	],
		// 	texCoord: [
		// 		0.0, 0.5,
		// 		0.5, 0.5,
		// 		0.0, 0.0,
		// 		0.5, 0.0,
		// 	],
		// });
		// // 左下
		// vertices.push({
		// 	pos: [
		// 		-1.0, -1.0,  0.0,
		// 		 0.0, -1.0,  0.0,
		// 		-1.0,  0.0,  0.0,
		// 		 0.0,  0.0,  0.0,
		// 	],
		// 	texCoord: [
		// 		0.0, 1.0,
		// 		0.5, 1.0,
		// 		0.0, 0.5,
		// 		0.5, 0.5,
		// 	],
		// });

		// インデックスバッファ生成 & 登録
		var indexData = [
			0, 1, 2,
			1, 3, 2,
		];
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.createIBO(indexData));

		var that = this;
		vertices.forEach(function(vertex){
			var vbo_array = [
				{
					buffer: that.createVBO(vertex.pos),
					location: gl.getAttribLocation(that.program, 'position'),
					stride: 3
				},
				{
					buffer: that.createVBO(vertex.texCoord),
					location: gl.getAttribLocation(that.program, 'texCoord'),
					stride: 2
				},
			];
			vbo_array.forEach(function(item, idx) {
				gl.bindBuffer(gl.ARRAY_BUFFER, item.buffer);
				gl.enableVertexAttribArray(item.location);
				gl.vertexAttribPointer(item.location, item.stride, gl.FLOAT, false, 0, 0);
			});

			gl.drawElements(gl.TRIANGLES, indexData.length, gl.UNSIGNED_SHORT, 0);
		});

		// コンテキストの再描画
		gl.flush();
	}

	Graphics.prototype.compileShader = function(shader, source) {
		var gl = this.gl;

		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.log(gl.getShaderInfoLog(shader));
			return;
		}
	}
	
	// VBOを生成する関数
	Graphics.prototype.createVBO = function(data) {
		var gl = this.gl;
		var buf = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buf);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		return buf;
	}

	// IBOを生成する関数
	Graphics.prototype.createIBO = function(data) {
		var gl = this.gl;

		var buf = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
		return buf;
	}
	
	// テクスチャを生成する関数
	Graphics.prototype.createTexture = function(source) {
		var that = this;
		var gl = this.gl;

		var img = new Image();
		img.onload = function() {
			var tex = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, tex);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
			gl.generateMipmap(gl.TEXTURE_2D);
			gl.bindTexture(gl.TEXTURE_2D, null);
			that.texture = tex;
		};

		img.src = that.texture_source;
	}

	function main() {
		// パーツ初期化
		view.init();

		// グラフィック処理開始
		var g = new Graphics();

		// 初期化
		if (!g.init()) {
			console.log("WebGL 初期化失敗！");
			return;
		}

		const fps = 60;
		var frameCount = 0;
		var now;
		var last;
		var elapsed = 0;

		(function() {
			now = new Date().getTime();
			if (!last) {
				last = now;
			}
			elapsed += (now - last);
			last = now;

			frameCount++;

			if (elapsed >= 1000) {
				ragii.dom.getElem("#fps").innerText = frameCount + " FPS";
				frameCount = 0;
				elapsed -= 1000;
			}

			// 描画
			g.render();

			setTimeout(arguments.callee, 1000 / fps);
		})();
	}

</script>

</head>

<body onload="main()">

	<select id="comboEffectSelector">
		<option value="0">通常</option>
		<option value="1">グレースケール</option>
		<option value="2">2値化</option>
		<option value="3">二次微分 laplacian 4方向</option>
		<option value="4">二次微分 laplacian 8方向</option>
		<option value="5">一次微分 Roberts</option>
		<option value="6">Prewitt</option>
		<option value="7">階調反転</option>
		<option value="8">色深度 8ビット</option>
		<option value="9">色深度 15ビット</option>
		<option value="10">色深度 16ビット</option>
		<option value="11">色深度 24ビット</option>
		<option value="12">色深度 32ビット</option>
		<option value="13">円</option>
		<option value="14">球</option>
		<option value="15">正弦波</option>
		<option value="16">鮮やか</option>
	</select>

	<br />
	<br />

	<table>
		<tr>
			<td>
				<p id="fps"></p>
				<canvas id="canvas" width="512" height="512">
				</canvas>
			</td>
			<td>
				<label>R    </label><input id="slider_color_r" type="range" min="0" max="255" step="1" value="0" /><label id="label_color_r_value"></label><br />
				<label>G    </label><input id="slider_color_g" type="range" min="0" max="255" step="1" value="0" /><label id="label_color_g_value"></label><br />
				<label>B    </label><input id="slider_color_b" type="range" min="0" max="255" step="1" value="0" /><label id="label_color_b_value"></label><br />
				<label>A    </label><input id="slider_color_a" type="range" min="0" max="255" step="1" value="0" /><label id="label_color_a_value"></label><br />
				<div class="vivid_params">
				  <label>鮮やかさ K1</label><input id="slider_vivid_k1" type="range" min="-1.5" max="1.5" step="0.1" value="1.0" /><label id="label_vivid_k1_value"></label><br />
				</div>
				<div class="vivid_params">
				  <label>鮮やかさ K2</label><input id="slider_vivid_k2" type="range" min="-1.5" max="1.5" step="0.1" value="1.0" /><label id="label_vivid_k2_value"></label><br />
				</div>
			</td>
		</tr>
	</table>

</body>

</html>