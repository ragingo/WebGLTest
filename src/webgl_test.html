<!DOCTYPE html>
<html>
<head>
<title>Shader Practice</title>

<script type="text/javascript">

    // ragii
    // 便利な何かの詰め合わせ
    var ragii = {
        dom: {
            // Elements 取得
            // #key  : getElementById(key)
            // .key  : getElementsByClassName(key)
            // <key> : getElementsByTagName(key)
            //  key  : getElementByName(key)
            getElems: function(key) {
                if (!key) {
                    return null;
                }

                var elems = null;
                if (key[0] == '#') {
                    elems = [ document.getElementById(key.substr(1)) ];
                }
                else if (key[0] == '.') {
                    elems = document.getElementsByClassName(key.substr(1));
                }
                else if (/^<[0-9a-zA-Z]+>$/.test(key)) {
                    var name = key.substring(1, key.length - 1);
                    elems = document.getElementsByTagName(name);
                }
                else {
                    elems = [ document.getElementByName(key) ];
                }
                return elems;
            },
            getElem: function(key) {
                var elems = this.getElems(key);
                if (elems.length > 0) {
                    return elems[0];
                }
                return null;
            }
        },
        http: {
            // GET リクエスト
            get: function(url, callback) {
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechanged = function() {
                    if (xhr.readyState != 4) {
                        return;
                    }
                    if (xhr.status != 200) {
                        return;
                    }
                    if (callback) {
                        callback(xhr);
                    }
                };
                xhr.open("GET", url);
                xhr.send();
            },
            // GET リクエスト
            // バイナリデータ受信
            getBinary: function(url, callback) {
                this.get(url, function(xhr) {
                    if (!xhr.responseBody) {
                        return;
                    }
                    var buf = new Uint8Array(xhr.responseBody);
                    if (callback) {
                        callback(buf);
                    }
                });
            }
        },
        image: {
            // 埋め込み画像用URI文字列化
            toDataUriString(binary, type) {
                if (!binary) {
                    return "";
                }
                if (binary.length == 0) {
                    return "";
                }
                var base64 = window.btoa(binary);
                return "data:image/" + type + ";base64," + base64;
            }
        }
    };

    // View
    var view = {

        // スライダ群
        sliders: null,

        // エフェクト選択ドロップダウン
        effectSelector: null,

        // 描画対象のキャンバス
        canvas: null,

        // 初期化
        init: function() {
            // スライダ初期化
            this.sliders = {
                r: { body: ragii.dom.getElem("#slider_color_r"), label: ragii.dom.getElem("#label_color_r_value") },
                g: { body: ragii.dom.getElem("#slider_color_g"), label: ragii.dom.getElem("#label_color_g_value") },
                b: { body: ragii.dom.getElem("#slider_color_b"), label: ragii.dom.getElem("#label_color_b_value") },
                a: { body: ragii.dom.getElem("#slider_color_a"), label: ragii.dom.getElem("#label_color_a_value") },
                vivid_k1: { body: ragii.dom.getElem("#slider_vivid_k1"), label: ragii.dom.getElem("#label_vivid_k1_value") },
                vivid_k2: { body: ragii.dom.getElem("#slider_vivid_k2"), label: ragii.dom.getElem("#label_vivid_k2_value") },
            };
            {
                var that = this;
                this.sliders.r.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.r); };
                this.sliders.g.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.g); };
                this.sliders.b.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.b); };
                this.sliders.a.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.a); };
                this.sliders.vivid_k1.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.vivid_k1); };
                this.sliders.vivid_k2.body.oninput = function() { return that.onColorSliderValueChanged(that.sliders.vivid_k2); };
            }

            this.effectSelector = ragii.dom.getElem('#comboEffectSelector');
            this.effectSelector.onchange = this.onEffectTypeSelectedValueChanged;

            this.canvas = ragii.dom.getElem('#canvas');
        },

        // 色指定スライダーの値変更時
        onColorSliderValueChanged: function(slider) {
            slider.label.innerText = slider.body.value;
        },

        // エフェクト種別切替時
        onEffectTypeSelectedValueChanged: function() {
            if (view.getSelectedEffectType() == 16) {
                Array.prototype.forEach.call(
                    ragii.dom.getElems(".vivid_params"),
                    function(elem) {
                        elem.style.visibility = "visible";
                    }
                );
            }
            else {
                Array.prototype.forEach.call(
                    ragii.dom.getElems(".vivid_params"),
                    function(elem) {
                        elem.style.visibility = "collapse";
                    }
                );
            }
        },

        getSelectedEffectType: function() {
            var value = this.effectSelector.options[this.effectSelector.selectedIndex].value;
            return parseInt(value, 10);
        },

        getEditColor: function() {
            return [
                this.sliders.r.body.value,
                this.sliders.g.body.value,
                this.sliders.b.body.value,
                this.sliders.a.body.value
            ];
        },

        getVividEffectParameters: function() {
            return [
                this.sliders.vivid_k1.body.value,
                this.sliders.vivid_k2.body.value
            ];
        },
    };

    // Shader Source Code
    var shaderSource = {
        vertex: null,
        fragment: null,
        load: function() {
            this.vertex = ragii.dom.getElem('#vs');
            this.fragment = ragii.dom.getElem('#fs');
        },
    };

    // https://wgld.org/d/webgl/w026.html を参考にして色々書き換え

    // 頂点情報
    var vertexInfo = {
        // 頂点インデックス
        index: [
            0, 1, 2,
            1, 3, 2,
        ]
    };

    // グラフィックスクラス
    var Graphics = function() {
        this.gl = null;
        this.program = null;
        this.texture = null;
        this.texture_source = "Lenna.png";
        //this.texture_source = "sample1.jpg";
    };

    // 初期化
    Graphics.prototype.init = function() {

        this.gl = view.canvas.getContext('webgl');
        if (!this.gl) {
            return false;
        }

        var gl = this.gl;

        this.program = gl.createProgram();

        shaderSource.load();

        // vs 生成 & コンパイル
        var vs = this.createShader(shaderSource.vertex.type);
        this.compileShader(vs, shaderSource.vertex.text);
        gl.attachShader(this.program, vs);

        // fs 生成 & コンパイル
        var fs = this.createShader(shaderSource.fragment.type);
        this.compileShader(fs, shaderSource.fragment.text);
        gl.attachShader(this.program, fs);

        gl.linkProgram(this.program);

        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
            console.log(gl.getProgramInfoLog(this.program));
            return false;
        }

        gl.useProgram(this.program);
        
        // IBO 登録
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.createIBO(vertexInfo.index));
        
        // 深度テストの有効化
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        
        gl.activeTexture(gl.TEXTURE0);
        
        this.createTexture(this.texture_source);

        return true;
    }

    Graphics.prototype.render = function() {
        var gl = this.gl;
        // クリア
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        var uniformLocation = {
            texture: gl.getUniformLocation(this.program, 'texture'),
            effectType: gl.getUniformLocation(this.program, 'effectType'),
            textureSize: gl.getUniformLocation(this.program, 'textureSize'),
            editColor: gl.getUniformLocation(this.program, 'editColor'),
            vividParams: gl.getUniformLocation(this.program, 'vividParams'),
        }
        
        // テクスチャ登録
        gl.uniform1i(uniformLocation.texture, 0);
        gl.uniform2fv(uniformLocation.textureSize, [canvas.width, canvas.height]);
        gl.uniform4fv(uniformLocation.editColor, view.getEditColor());
        gl.uniform2fv(uniformLocation.vividParams, view.getVividEffectParameters());

        // エフェクト切り替え
        gl.uniform1i(uniformLocation.effectType, view.getSelectedEffectType());

        // TODO: texCoord から算出して pos を生成
        // 頂点バッファ更新
        var vertices = [];
        // 左上
        vertices.push({
            pos: [
                -1.0,  0.0,  0.0,
                0.0,  0.0,  0.0,
                -1.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
            ],
            texCoord: [
                0.0, 0.5,
                0.5, 0.5,
                0.0, 0.0,
                0.5, 0.0,
            ],
        });
        // 左下
        vertices.push({
            pos: [
            -1.0, -1.0,  0.0,
             0.0, -1.0,  0.0,
            -1.0,  0.0,  0.0,
             0.0,  0.0,  0.0,
            ],
            texCoord: [
                0.0, 1.0,
                0.5, 1.0,
                0.0, 0.5,
                0.5, 0.5,
            ],
        });

        var that = this;
        vertices.forEach(function(vertex){
            var vbo_array = [
                {
                    buffer: that.createVBO(vertex.pos),
                    location: gl.getAttribLocation(that.program, 'position'),
                    stride: 3
                },
                {
                    buffer: that.createVBO(vertex.texCoord),
                    location: gl.getAttribLocation(that.program, 'texCoord'),
                    stride: 2
                },
            ];
            vbo_array.forEach(function(item, idx) {
                gl.bindBuffer(gl.ARRAY_BUFFER, item.buffer);
                gl.enableVertexAttribArray(item.location);
                gl.vertexAttribPointer(item.location, item.stride, gl.FLOAT, false, 0, 0);
            });

            gl.drawElements(gl.TRIANGLES, vertexInfo.index.length, gl.UNSIGNED_SHORT, 0);
        });
        
        // コンテキストの再描画
        gl.flush();
    }

    // シェーダを生成する関数
    Graphics.prototype.createShader = function(type, source) {
        var gl = this.gl;
        switch (type) {
            case 'x-shader/x-vertex':
                return gl.createShader(gl.VERTEX_SHADER);

            case 'x-shader/x-fragment':
                return gl.createShader(gl.FRAGMENT_SHADER);
        }
    }

    Graphics.prototype.compileShader = function(shader, source) {
        var gl = this.gl;

        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.log(gl.getShaderInfoLog(shader));
            return;
        }
    }
    
    // VBOを生成する関数
    Graphics.prototype.createVBO = function(data) {
        var gl = this.gl;
        var buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return buf;
    }

    // IBOを生成する関数
    Graphics.prototype.createIBO = function(data) {
        var gl = this.gl;

        var buf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        return buf;
    }
    
    // テクスチャを生成する関数
    Graphics.prototype.createTexture = function(source) {
        var that = this;
        var gl = this.gl;

        var img = new Image();
        img.onload = function() {
            var tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
            that.texture = tex;
        };
        
        //img.crossOrigin = "";
        img.src = that.texture_source;

        // ragii.http.getBinary(source, function(binary) {
        //     var type;
        //     if (source.toLowerCase().endsWith(".jpg") || source.toLowerCase().endsWith(".jpeg")) {
        //         type = "jpg";
        //     }
        //     else if (source.toLowerCase().endsWith(".png")) {
        //         type = "png";
        //     }
        //     else {
        //         type = "jpg";
        //     }

        //     var dataUri = ragii.image.toDataUriString(binary, type);

        //     var img = new Image();
        //     img.onload = function() {
        //         var tex = gl.createTexture();
        //         gl.bindTexture(gl.TEXTURE_2D, tex);
        //         gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        //         gl.generateMipmap(gl.TEXTURE_2D);
        //         gl.bindTexture(gl.TEXTURE_2D, null);
        //         that.texture = tex;
        //     };
            
        //     img.src = dataUri;
        // });
    }

    function main() {
        // パーツ初期化
        view.init();

        // グラフィック処理開始
        var g = new Graphics();

        // 初期化
        if (!g.init()) {
            console.log("WebGL 初期化失敗！");
            return;
        }

        const fps = 60;
        var frameCount = 0;
        var now;
        var last;
        var elapsed = 0;

        (function() {
            now = new Date().getTime();
            if (!last) {
                last = now;
            }
            elapsed += (now - last);
            last = now;

            frameCount++;

            if (elapsed >= 1000) {
                ragii.dom.getElem("#fps").innerText = frameCount + " FPS";
                frameCount = 0;
                elapsed -= 1000;
            }

            // 描画
            g.render();

            setTimeout(arguments.callee, 1000 / fps);
        })();
    }

</script>

<!-- 頂点シェーダ -->
<script id="vs" type="x-shader/x-vertex">

attribute vec3 position;
attribute vec4 color;
attribute vec2 texCoord;
varying   vec2 vTextureCoord;

mat4 mat4_identity() {
    return mat4(
        vec4(1.0, 0.0, 0.0, 0.0),
        vec4(0.0, 1.0, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    );
}

mat4 mat4_scale(vec3 value) {
    return mat4(
        vec4(value.x, 0.0, 0.0, 0.0),
        vec4(0.0, value.y, 0.0, 0.0),
        vec4(0.0, 0.0, value.z, 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    );
}

mat4 mat4_translate(vec3 value) {
    return mat4(
        vec4(1.0, 0.0, 0.0, 0.0),
        vec4(0.0, 1.0, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(value.x, value.y, value.z, 1.0)
    );
}

mat4 mat4_rotate_x(float rad) {
    return mat4(
        vec4(1.0, 0.0, 0.0, 0.0),
        vec4(0.0, cos(rad), -sin(rad), 0.0),
        vec4(0.0, sin(rad), cos(rad), 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    );
}

void main() {
    vTextureCoord = texCoord;
    mat4 mat_result = mat4_identity();
    gl_Position   = mat_result * vec4(position, 1.0);
}

</script>

<!-- フラグメントシェーダ -->
<script id="fs" type="x-shader/x-fragment">

precision mediump float;

uniform sampler2D texture;
uniform int       effectType;
uniform vec2      textureSize;
uniform vec4      editColor;
uniform vec2      vividParams;
varying vec2      vTextureCoord;

// 外部指定の色を掛ける
vec4 apply_edit_color(vec4 color) {
    return color * (editColor / 255.0);
}

// グレースケール
vec4 grayscale(vec4 color) {
    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
    return vec4(gray, gray, gray, color.a);
}

// 2値化
vec4 binarize(vec4 color, float threshold) {
    if (color.r > threshold ||
        color.g > threshold ||
        color.b > threshold) {
        color = vec4(0.0, 0.0, 0.0, 1.0);
    }
    else {
        color = vec4(1.0, 1.0, 1.0, 1.0);
    }
    return color;
}

// 二次微分 laplacian 4方向
vec4 laplacian4(vec4 pix[9]) {
    vec4 d =
        0.0 * pix[0] + -1.0 * pix[1] +  0.0 * pix[2] +
       -1.0 * pix[3] +  4.0 * pix[4] + -1.0 * pix[5] +
        0.0 * pix[6] + -1.0 * pix[7] +  0.0 * pix[8];
    vec4 x = abs(d);
    return x;
}

// 二次微分 laplacian 8方向
vec4 laplacian8(vec4 pix[9]) {
    vec4 d =
        -1.0 * pix[0] + -1.0 * pix[1] + -1.0 * pix[2] +
        -1.0 * pix[3] +  8.0 * pix[4] + -1.0 * pix[5] +
        -1.0 * pix[6] + -1.0 * pix[7] + -1.0 * pix[8];
    vec4 x = abs(d);
    return x;
}

// 一次微分 Roberts
vec4 roberts(vec4 pix[9]) {
    vec4 dx =
         0.0 * pix[0] +  0.0 * pix[1] +  0.0 * pix[2] +
         0.0 * pix[3] +  1.0 * pix[4] +  0.0 * pix[5] +
         0.0 * pix[6] +  0.0 * pix[7] + -1.0 * pix[8];

    vec4 dy =
         0.0 * pix[0] +  0.0 * pix[1] +  0.0 * pix[2] +
         0.0 * pix[3] +  0.0 * pix[4] +  1.0 * pix[5] +
         0.0 * pix[6] + -1.0 * pix[7] +  0.0 * pix[8];

    vec4 x = sqrt(pow(dx,vec4(2.0)) + pow(dy,vec4(2.0))) * 0.5;
    return x;
}

// Prewitt
// TODO: だいぶ前に書いてみたやつだったけど、計算全然違うものかも？！
vec4 prewitt(vec4 pix[9]) {
    for (int i = 0; i < 9; i++) {
        pix[i] = grayscale(pix[i]); // グレースケール化して上書き
    }

    vec4 m[8];
    m[0] =  pix[0] + pix[1] + pix[2] + pix[3] - 2.0 * pix[4] + pix[5] - pix[6] - pix[7] - pix[8];
    m[1] =  pix[0] + pix[1] + pix[2] + pix[3] - 2.0 * pix[4] - pix[5] + pix[6] - pix[7] - pix[8];
    m[2] =  pix[0] + pix[1] - pix[2] + pix[3] - 2.0 * pix[4] - pix[5] + pix[6] + pix[7] - pix[8];
    m[3] =  pix[0] - pix[1] - pix[2] + pix[3] - 2.0 * pix[4] - pix[5] + pix[6] + pix[7] + pix[8];
    m[4] = -pix[0] - pix[1] - pix[2] + pix[3] - 2.0 * pix[4] + pix[5] + pix[6] + pix[7] + pix[8];
    m[5] = -pix[0] - pix[1] + pix[2] - pix[3] - 2.0 * pix[4] + pix[5] + pix[6] + pix[7] + pix[8];
    m[6] = -pix[0] + pix[1] + pix[2] - pix[3] - 2.0 * pix[4] + pix[5] - pix[6] + pix[7] + pix[8];
    m[7] =  pix[0] + pix[1] + pix[2] - pix[3] - 2.0 * pix[4] + pix[5] - pix[6] - pix[7] + pix[8];

    vec4 n = vec4(0.0);
    for (int i = 0; i < 8; i++) {
        n = max(n, m[i]);
    }
    vec4 x = n * 0.8;
    return x;
}

// 階調反転
vec4 reverse(vec4 pix) {
    return vec4(vec3(1.0) - pix.rgb, 1.0);
}

// 色深度変換
// TODO: 式合ってるのか？
vec4 convert_colordepth(vec4 pix, int depth) {
    vec4 result = pix;

    if (depth == 8) {
        // r 3bit, g 3bit, b 2bit
        result = vec4(floor(pix.rgb * vec3(8.0, 8.0, 4.0)) / (vec3(8.0, 8.0, 4.0) - 1.0), 1.0);
    }
    if (depth == 15) {
        // r 5bit, g 5bit, b 5bit
        result = vec4(floor(pix.rgb * vec3(32.0, 32.0, 32.0)) / (vec3(32.0, 32.0, 32.0) - 1.0), 1.0);
    }
    if (depth == 16) {
        // r 5bit, g 6bit, b 5bit
        result = vec4(floor(pix.rgb * vec3(32.0, 64.0, 32.0)) / (vec3(32.0, 64.0, 32.0) - 1.0), 1.0);
    }
    if (depth == 24) {
        result = vec4(floor(pix.rgb * vec3(256.0, 256.0, 256.0)) / (vec3(256.0, 256.0, 256.0) - 1.0), 1.0);
    }
    if (depth == 32) {
        result = pix;
    }

    return result;
}

// 周辺ピクセル取得
void get_neighbour_pixels(out vec4 pix[9]) {
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            vec2 offset = vec2(1.0 / textureSize.x, 1.0 / textureSize.y);
            float x = vTextureCoord.x + (float(col)-1.0) * offset.x;
            float y = vTextureCoord.y + (float(row)-1.0) * offset.y;
            vec2 kernel = vec2(x, y);
            vec4 result = texture2D(texture, kernel);

            pix[row+col] = apply_edit_color(result); // 外部指定色を掛けて更新
        }
    }
}

// 円
vec4 circle(vec4 pix) {
    vec2 inv = vec2(1.0 / textureSize.x, 1.0 / textureSize.y);

    // 中心
    vec2 center = (textureSize.x * 0.5) * inv;

    // 現在位置
    vec2 uv = vTextureCoord.xy;

    vec4 result = pix;

    // 横線
    if (int(uv.x * 1000.0) == int(center.x * 1000.0)) {
        result = mix(result, vec4(0.0, 0.0, 1.0, 1.0), 0.5);
    }
    // 縦線
    if (int(uv.y * 1000.0) == int(center.y * 1000.0)) {
        result = mix(result, vec4(0.0, 0.0, 1.0, 1.0), 0.5);
    }

    // 半径
    float r = 100.0 * inv.x;

    // 円
    if (length(uv - center) < r) {
        result = mix(result, vec4(1.0, 0.0, 0.0, 1.0), 0.5);
        //discard;
    }

    return result;
}

// 球
vec4 sphere(vec4 pix) {
    vec2 inv = vec2(1.0 / textureSize.x, 1.0 / textureSize.y);
    vec2 center = (textureSize.x * 0.5) * inv;
    float r = 100.0 * inv.x;
    vec2 uv = vTextureCoord.xy;
    vec2 pos = uv - center;

    float z = sqrt(pow(r, 2.0) - pow(pos.x, 2.0) - pow(pos.y, 2.0)) / r;

    vec4 result = mix(pix, vec4(vec3(z), 1.0), 0.5);

    return result;
}

// 正弦波
vec4 sine_wave(vec4 pix) {
    vec2 inv = vec2(1.0 / textureSize.x, 1.0 / textureSize.y);
    vec2 center = (textureSize.x * 0.5) * inv;
    vec2 uv = vTextureCoord.xy;

    // 下地
    vec4 result = vec4(0.0, 0.0, 0.0, 0.1);

    float pi = 3.1415926535;
    float amp = 0.1;
    float freq = 600.0;
    float wave = amp * sin(uv.x/180.0 * pi * freq);
    vec2 new_wave = vec2(uv.x, uv.y + wave);

    result = texture2D(texture, new_wave);
    result = apply_edit_color(result);

    return result;
}

// 鮮やか
vec4 vivid(vec4 pix, float k1, float k2) {
    mat3 m = mat3(
        vec3(k1, k2, k2),
        vec3(k2, k1, k2),
        vec3(k2, k2, k1)
    );
    vec3 rgb = m * pix.rgb;
    vec4 result = vec4(rgb, 1.0);

    return result;
}

void main() {

    // 元の色
    vec4 color = texture2D(texture, vTextureCoord);

    color *= apply_edit_color(color);

    if (effectType == 0) {
        gl_FragColor = color;
    }

    if (effectType == 1) {
        gl_FragColor = grayscale(color);
    }

    if (effectType == 2) {
        gl_FragColor = binarize(color, 0.1);
    }

    if (effectType == 3) {
        vec4 pix[9];
        get_neighbour_pixels(pix);
        gl_FragColor = laplacian4(pix);
    }

    if (effectType == 4) {
        vec4 pix[9];
        get_neighbour_pixels(pix);
        gl_FragColor = laplacian8(pix);
    }

    if (effectType == 5) {
        vec4 pix[9];
        get_neighbour_pixels(pix);
        gl_FragColor = roberts(pix);
    }

    if (effectType == 6) {
        vec4 pix[9];
        get_neighbour_pixels(pix);
        gl_FragColor = prewitt(pix);
    }

    if (effectType == 7) {
        gl_FragColor = reverse(color);
    }

    if (effectType == 8) {
        gl_FragColor = convert_colordepth(color, 8);
    }

    if (effectType == 9) {
        gl_FragColor = convert_colordepth(color, 15);
    }

    if (effectType == 10) {
        gl_FragColor = convert_colordepth(color, 16);
    }

    if (effectType == 11) {
        gl_FragColor = convert_colordepth(color, 24);
    }

    if (effectType == 12) {
        gl_FragColor = convert_colordepth(color, 32);
    }

    if (effectType == 13) {
        gl_FragColor = circle(color);
    }

    if (effectType == 14) {
        gl_FragColor = sphere(color);
    }

    if (effectType == 15) {
        gl_FragColor = sine_wave(color);
    }

    if (effectType == 16) {
        gl_FragColor = vivid(color, vividParams.x, vividParams.y);
    }

}

</script>

</head>

<body onload="main()">

    <select id="comboEffectSelector">
        <option value="0">通常</option>
        <option value="1">グレースケール</option>
        <option value="2">2値化</option>
        <option value="3">二次微分 laplacian 4方向</option>
        <option value="4">二次微分 laplacian 8方向</option>
        <option value="5">一次微分 Roberts</option>
        <option value="6">Prewitt</option>
        <option value="7">階調反転</option>
        <option value="8">色深度 8ビット</option>
        <option value="9">色深度 15ビット</option>
        <option value="10">色深度 16ビット</option>
        <option value="11">色深度 24ビット</option>
        <option value="12">色深度 32ビット</option>
        <option value="13">円</option>
        <option value="14">球</option>
        <option value="15">正弦波</option>
        <option value="16">鮮やか</option>
    </select>

    <br />
    <br />

    <table>
        <tr>
            <td>
                <p id="fps"></p>
                <canvas id="canvas" width="512" height="512">
                </canvas>
            </td>
            <td>
                <label>R    </label><input id="slider_color_r" type="range" min="0" max="255" step="1" value="0" /><label id="label_color_r_value"></label><br />
                <label>G    </label><input id="slider_color_g" type="range" min="0" max="255" step="1" value="0" /><label id="label_color_g_value"></label><br />
                <label>B    </label><input id="slider_color_b" type="range" min="0" max="255" step="1" value="0" /><label id="label_color_b_value"></label><br />
                <label>A    </label><input id="slider_color_a" type="range" min="0" max="255" step="1" value="0" /><label id="label_color_a_value"></label><br />
                <div class="vivid_params">
                  <label>鮮やかさ K1</label><input id="slider_vivid_k1" type="range" min="-1.5" max="1.5" step="0.1" value="1.0" /><label id="label_vivid_k1_value"></label><br />
                </div>
                <div class="vivid_params">
                  <label>鮮やかさ K2</label><input id="slider_vivid_k2" type="range" min="-1.5" max="1.5" step="0.1" value="1.0" /><label id="label_vivid_k2_value"></label><br />
                </div>
            </td>
        </tr>
    </table>


    <!-- <br /> -->

    <!-- https://www.google.co.jp/search?q=%E6%99%AF%E8%89%B2&biw=1920&bih=950&tbm=isch&source=lnt&tbs=isz:ex,iszw:1024,iszh:1024 -->
    <!-- <img src="sample1.jpg" /> -->

</body>

</html>